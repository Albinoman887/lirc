<A NAME="lircd"><HR></A>
<H1 ALIGN="CENTER">lircd</H1>
<HR WIDTH="70%">

<P> LIRC daemon - decodes infrared signals and provides them on a Unix
domain socket</P>

<PRE>
  <B>lircd</B> [config_file]
  <B>lircd</B> -h | --help
  <B>lircd</B> -v | --version
</PRE>

<P>
The main task of lircd is to decode the infrared signals and provide
an uniform interface for client applications. Clients can connect to
lircd through a Unix domain socket which is located in
<em>/dev/lircd</em>. Using this socket they will get the infrared
codes received by lircd and they can send commands to lircd.
</P>

<P>
The config file for lircd is located in
<em>/usr/local/etc/lircd.conf</EM>. lircd has its own log file in
<em>/var/log/lircd</em>. You can make lircd reread its config file and
reopen its log file by sending the HUP signal to the program. That way
you can rotate old log files.
</P>

<P>Read also the <A HREF="#daemons">daemon note</A>.</P>

<A NAME="lircmd"><HR></A>
<H1 ALIGN="CENTER">lircmd</H1>
<HR WIDTH="70%">

<P>
LIRC mouse daemon - translates infrared signals into mouse events
</P>

<PRE>
  <B>lircmd</B> [config_file]
  <B>lircmd</B> -h | --help
  <B>lircmd</B> -v | --version
</PRE>

<P>This daemon can simulate a MouseSystems or IMPS/2 type mouse. It
gets the received buttons from lircd and converts them to mouse
events. To make this possible, lircmd needs a config file located in
<em>/usr/local/etc/lircmd.conf</em>. In this file you have to
determine which button from which remote causes a mouse move or a
mouse button click.
</P>

<P>
lircmd will use syslogd to output error messages. It depends on your
system configuration where they will show up.
</P>

<P>Read also the <A HREF="#daemons">daemon note</A>.</P>

<A NAME="daemons"><P><B>Usage of the Daemons</B></P></A>

<P>
lircd and lircmd are daemons.  You should start them in some init
script depending on your system.  There are some example scripts for
different distributions in the <em>contrib</em> directory. lircmd has
to be started after lircd as it connects to the socket lircd provides.
</P>

<P>
If you start lircd or lircmd from your shell prompt you will usually
get back immediately to the prompt. Often people think that the
program has died. But this is not an error. lircd and lircmd are
daemons. Daemons always run in background.
</P>

<A NAME="irexec"><HR></A>
<H1 ALIGN="CENTER">irexec</H1>
<HR WIDTH="70%">

<P>irexec - run programs with one button press</P>

<PRE>
  <B>irexec</B> [config_file]
</PRE>

<P>This program lets you execute arbitrary commands on an IR signal
decoded by lircd, the LIRC daemon. You can give irexec a command line
parameter which has to be a name of a valid config file. If no command
line parameters are given irexec reads the default config file which
is usually ~/.lircrc.  If irexec executes a program it will wait until
this program terminates. So append a '&' to the command string if you
don't want that.

<P>The config string consists of the command to be run.</P>

<P><B>Note:</B> If you start irexec, it reads your <A
HREF="configure.html#lircrc_format">~/.lircrc</A> and reacts only on
<em>prog=</em> entries that point to irexec. If you have included more
than one program in your .lircrc, then start all these programs, they
react itself only to their according entries in .lircrc.</P>


<A NAME="irpty"><HR></A>
<H1 ALIGN="CENTER">irpty</H1>
<HR WIDTH="70%">

<P>irpty - pseudo tty driver</P>

<PRE>
  <B>irpty</B> [-s socket_name] [-e] [-i] [-n] [-v] config_file program [args ...]
</PRE>

<P>
irpty connects to lircd to receive infrared codes and converts them to
key strokes. E.g. type <em>irpty ~/.lircrc workbone</em> to control
the CD-player program workbone. Of course you will have to create an
appropriate config file for this purpose first.  The config string
will be passed to the desired application. Note that you can use
escape sequences to specify non printable characters. Have a look at
the .lircrc <A HREF="configure.html#lircrc_format">file format</A>
descriptions for details.
</P>
<P>
irpty accepts the following options:
</P>
    <DL>
      <DT>-s socket_name</DT>
      <DD>
	select a non-default socket location
      </DD>
      <DT>-e</DT>
      <DD>
	disable echo
      </DD>
      <DT>-i</DT>
      <DD>
	ingore EOF
      </DD>
      <DT>-n</DT>
      <DD>
	force non-interactive mode
      </DD>
      <DT>-v</DT>
      <DD>
	verbose mode
      </DD>
    </DL>      

<A NAME="irxevent"><HR></A> <H1 ALIGN="CENTER">irxevent</H1>
<HR WIDTH="70%">

<P>irxevent  - infrared X-event sender</P>

<PRE>
  <B>irxevent</B> [config_file]
</PRE>


<P>
by Heinrich Langos &lt;heinrich@mad.scientist.com&gt;
</P>

<P>
Irxevent is a program that I wrote to send button clicks and key
presses to X applications triggered by a LIRC driven remote
control. You can control your favorite CD/MP3 player or your TV tuner
program or any other X application that responds to keyboard or mouse
input. If you like to you can send emacs ^X^S from your armchair.
</P>

<P>
Irxevent is a complement to irexec and irpty and works with the same
config file. (~/.lircrc) For a complete sample-.lircrc look at
<em>examples/lircrc</em>.
</P>

<P>Part of your .lircrc could look like this:</P>
<HR>
<PRE>
begin
        prog = irxevent
        button = VIDEO_UP    
        config = Key SHIFT-KP_Add CurrentWindow
end
begin
        prog = irxevent
        button = VIDEO_DOWN
        config = Key SHIFT-KP_Subtract CurrentWindow
end
begin
        prog = irxevent
        button = STOP
        config = Key ctrl-c CurrentWindow
end
begin
        prog = irxevent
        button = 0
        config = Key f xawtv
        config = Key f xawtv
end
begin
        prog = irxevent
        button = POWER
        config = Key q xawtv
end
begin
        prog = irxevent
        button = CH_DOWN
        config = Button 1 329 92 kscd
end
begin
        prog = irxevent
        button = UP
        config = Button 1 110 80 GQmpeg
end
begin
        prog = irxevent
        button = DOWN
        config = Button 1 130 80 GQmpeg
end
</PRE>
<HR>

<P>
Simply said <em>config =</em> lines may look like this:
</P>

<PRE>
config = Key [shift-][ctrl-][alt-]&lt;key&gt; &lt;windowname&gt; | CurrentWindow
config = Button &lt;button&gt; &lt;x&gt; &lt;y&gt; &lt;windowname&gt; | CurrentWindow
config = xy_Key &lt;x&gt; &lt;y&gt; [shift-][ctrl-][alt-] &lt;key&gt;&lt;windowname&gt; | CurrentWindow
</PRE>

<P>some more examples:</P>
<HR>
<PRE>
config = Key Up xawtv
config = Key Down xawtv
config = Button 1 50 110 xclickme
config = Key q xawtv
config = Key ctrl-c mpg123
config = Key shift-Page_Up rxvt
</PRE>
<HR>


<P>In BNF this looks like:</P>

<PRE>
LINE    = &quot;config =&quot; &lt;KEY|BUTTON|XYKEY&gt; &lt;TARGET&gt;
XYKEY   = &quot;xy_Key&quot; &lt;x_position&gt; &lt;y_position&gt; &lt;MOD&gt;Keyname
KEY     = &quot;Key&quot; &lt;MOD&gt;Keyname
MOD     = [&quot;shift-&quot;][&quot;numlock-&quot;][&quot;ctrl-&quot;][&quot;alt-&quot;][&quot;meta-&quot;]
          [&quot;numlock-&quot;][&quot;mod3-&quot;][&quot;mod4-&quot;][&quot;scrlock-&quot;]
BUTTON  = &quot;Button&quot; &lt;1..5&gt; &lt;x_position&gt; &lt;y_position&gt;
TARGET  = Windowname | &quot;CurrentWindow&quot;
</PRE>


<DL>
<DT>Keyname</DT>
<DD>
is the key symbol that is declared in X windows. E.g. &quot;Up&quot;
refers to the cursor arrow pointing up.  &quot;KP_Add&quot; is the
plus sign on the key pad. Just take a look at <A
HREF="../irxevent.keys">irxevent.keys</A> if you are not sure about a
symbol's name.
</DD>
<DT>Windowname</DT>
<DD>
can be the first characters of the window name displayed by the window
manager or the name that is displayed below the icon.  Some programs
use the name displayed by the window manager to show a lot of status
information but don't change the icon name (like xawtv). Others append
information to the window name (&quot;GQmpeg -
kill_windooz.mp3&quot;). If neither window name nor icon name match
the given Windowname information from XClassHint(3x) will be checked.
</DD>
<DT>CurrentWindow</DT>
<DD>
refers to the active window as returned by XGetInputFocus(3x).  Most
times this is the window with your mouse pointer in it.
</DD>
</DL>

<P>
If you have problems finding the coordinates for a button click you
can try <NOBR><em>xev -id &lt;window_id&gt;</em></NOBR>. The window_id
can be found using <em>xwininfo</em>.  If xev and xwininfo are not
part of your distribution you can find them at a FTP server using the
search engine at: <A
HREF="http://ftpsearch.ntnu.no/">http://ftpsearch.ntnu.no/</A>.  xev
also reports the names of key symbols like &quot;Control_L&quot; (your
left control key) or &quot;KP_Subtract&quot; (the 'minus' key on your
keypad).
</P>

<P>
There are programs that do not accept any synthetic X-events by
default because they can cause security problems. Currently xterm and
xemacs are known to ignore events simulated by irxevent.
</P>

<P>
You can however make xterm accept external events by enabling
<NOBR>&quot;Allow SendEvents&quot;</NOBR> in the <NOBR>&quot;Main
Options&quot;</NOBR> (hold down the Ctrl button and press the left
mouse button inside the xterm window). You can as well place this line
into your .Xresources file to change this permanently:
<PRE>
  XTerm.vt100.allowSendEvents:    true
</PRE>
Yet another possibility is to start xterm like this:
<PRE>
  xterm -xrm "XTerm.vt100.allowSendEvents:    true"
</PRE>
xemacs will accept events if you set a built-in variable. The
following was taken from the online help:

<PRE>
`x-allow-sendevents' is a built-in boolean variable.

Value: t

Documentation:
*Non-nil means to allow synthetic events.  Nil means they are ignored.
Beware: allowing emacs to process SendEvents opens a big security hole.
</PRE>

In order to allow events you have to evaluate this lisp code (press
Meta-x and enter the following expression):
<PRE>
  (setq x-allow-sendevents t)
</PRE>
Placing this line into your <em>.xemacs-options</em> file should have
the same result.
</P>

<P>
If you have problems sending events please drop <A
HREF="mailto:heinrich@mad.scientist.com">me</A> an email.
</P>

<A NAME="irrecord"><HR></A> <H1 ALIGN="CENTER">irrecord</H1>
<HR WIDTH="70%">

<P>irrecord - application for recording IR-codes for usage with
LIRC</P>

<PRE>
  <B>irrecord</B> [-f | --force] file
  <B>irrecord</B> -h | --help
  <B>irrecord</B> -v | --version
</PRE>

<P>
This program will record the signals from your remote control and
create a config file for lircd. A proper config file for lircd is
maybe the most vital part of this package, so you should invest some
time to create a working config file.  Although I put a good deal of
effort in this program it is often not possible to automatically
recognize all features of a remote control.  Further information on
this topic is available in this <A HREF="help.html#new_remote">section</A>.
</P>
<P>
If the program fails to recognize the protocol of the remote control
you should use the --force option to at least create a config file in
raw mode.
</P>
<P>
This program is provided to you free of charge. So it'd be only fair
to respect its license.
</P>

<A NAME="irw"><HR></A>
<H1 ALIGN="CENTER">irw</H1>
<HR WIDTH="70%">

<P>irw - sends data from Unix domain socket to stdout</P>

<PRE>
  <B>irw</B> [socket_name]
</PRE>

<P>
irw will connect to any Unix domain socket and will print the data
that it receives to stdout. If you don't give it a socket name
argument it will watch /dev/lircd. Useful for debugging.
</P>



<A NAME="mode2"><HR></A>
<H1 ALIGN="CENTER">mode2, smode2, xmode2</H1>
<HR WIDTH="70%">

<P>mode2, smode2, xmode2 - shows the pulse/space length of infrared
signals</P>

<PRE>
  <B>mode2</B>
  <B>smode2</B> [-t ms/div]
  <B>xmode2</B> [-t ms/div]
</PRE>


<P>
The main purpose of these programs is to check operation of LIRC
receiver hardware and to see the IR waveform of the remote controller
without an expensive oscilloscope. Very useful for debugging. Of
course it does not make sense to use this programs with hardware that
decodes the signals itself.
</P>

<P>
mode2 will simply print pulse&amp;space lengths to stdout.
</P>

<P>
smode2 uses the svgalib to show the IR waveform in a graphical
representation.  The time division is variable from 1 ms/div to
extremely high values (integer type) but there is no point increasing
this value above 20 ms/div, because one pulse is about 1 ms. This kind
of presentation is much more exciting than the simple pulse&amp;space
output showed by mode2.
</P>

<P>
xmode2 is based on smode2 by Sinkovics Zoltan. It is just a
conversion from svga to X with some basic support for resizing.
</P>

