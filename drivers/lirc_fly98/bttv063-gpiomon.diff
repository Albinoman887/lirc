diff -u --recursive --new-file bttv-0.6.3/driver/MAKEDEV bttv-irctl/driver/MAKEDEV
--- bttv-0.6.3/driver/MAKEDEV	Tue Sep 29 02:31:30 1998
+++ bttv-irctl/driver/MAKEDEV	Thu Apr 29 01:11:38 1999
@@ -26,3 +26,6 @@
 makedev bttv 0
 makedev bttv-fm 64
 makedev bttv-vbi 224
+
+echo "*** Testing IRCtl in FV98 ***"
+mknod IRCtl c 61 0
diff -u --recursive --new-file bttv-0.6.3/driver/Makefile bttv-irctl/driver/Makefile
--- bttv-0.6.3/driver/Makefile	Thu Feb  4 00:51:18 1999
+++ bttv-irctl/driver/Makefile	Sat Jul 24 01:16:14 1999
@@ -9,7 +9,7 @@
 # 5: Philips PAL tuner
 # 6: Temic NTSC tuner
 # 7: Temic PAL tuner
-# TUNER=0
+TUNER=0
 # Do not select the tuner type here!
 # Edit the type argument for the tuner module in "update"!
 
@@ -35,7 +35,7 @@
 # 17: PXC200
 # 18: AVermedia98
 # 19: FlyVideo98 (newer FlyVideo cards)
-CARD=15
+CARD=19
 # This can be set using module parameters too.
 
 
@@ -51,7 +51,7 @@
 # use 1 or 2 if you have a Bt848A, Bt849, Bt878, Bt879
 # 1 == 28 MHz crystal installed
 # 2 == 34 MHz crystal installed
-PLL=-DUSE_PLL=2
+PLL=-DUSE_PLL=1
 # This can be set using module parameters too.
 
 
@@ -67,17 +67,18 @@
 #KERNEL_LOCATION=/usr/src/kernel/2.0.35
 #KERNEL_LOCATION=/usr/src/kernel/$(CURRENT)
 #KERNEL_LOCATION=/usr/src/kernel/vger
-KERNEL_LOCATION=/usr/src/linux
+KERNEL_LOCATION=/usr/src/local/linux
 
 
 #################################################
 # some magic for using linux kernel settings
 # when compiling module(s)
 
-M_OBJS       = bttv.o msp3400.o tuner.o #i2c_chardev.o
-MX_OBJS      = videodev.o i2c.o
+M_OBJS       = bttv.o msp3400.o tuner.o i2c_chardev.o
+MX_OBJS      = videodev.o i2c.o remote.o
 EXTRA_CFLAGS = -DTUNER_DEFAULT=$(TUNER) -DCARD_DEFAULT=$(CARD) \
-	-DBTTV_MAJOR=$(BTTV_MAJOR) $(INTERFACE) $(MSP) $(PLL) #-DVIDEODAT
+	-DBTTV_MAJOR=$(BTTV_MAJOR) $(INTERFACE) $(MSP) $(PLL) \
+	-DVIDEODAT -DGPIOMON
 
 here:
 	DIR=`pwd`; (cd $(KERNEL_LOCATION); make SUBDIRS=$$DIR modules)
@@ -85,8 +86,11 @@
 install:
 	su -c "cp -v $(M_OBJS) $(MX_OBJS) /lib/modules/$(CURRENT)/misc"
 
+readir: readirctl.c
+	cc readirctl.c -o readir
+
 clean:
-	-rm -f $(M_OBJS) $(MX_OBJS) .*.o.flags *~
+	-rm -f $(M_OBJS) $(MX_OBJS) .*.o.flags *~ readir
 
 include $(KERNEL_LOCATION)/Rules.make
 
diff -u --recursive --new-file bttv-0.6.3/driver/bttv.c bttv-irctl/driver/bttv.c
--- bttv-0.6.3/driver/bttv.c	Sun Feb  7 22:49:48 1999
+++ bttv-irctl/driver/bttv.c	Fri Jul 23 22:07:21 1999
@@ -18,6 +18,10 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
+#include <linux/config.h>
+#ifndef EXPORT_SYMTAB
+#define EXPORT_SYMTAB
+#endif
 
 #include <linux/module.h>
 #include <linux/delay.h>
@@ -130,6 +134,10 @@
 static int bttv_num;			/* number of Bt848s in use */
 static struct bttv bttvs[BTTV_MAX];
 
+#ifdef GPIOMON
+static bttv_gpio_monitor_t gpio_monitor=NULL;
+#endif
+
 #define I2C_TIMING (0x7<<4)
 #define I2C_DELAY   10
 
@@ -580,6 +588,9 @@
         { "FlyVideo 98",
           3, 0, 2, 0x8dff00, {2, 3, 1, 1}, 
           {0, 0x8dff00, 0x800, 0x400, 0x8dff00, 0 }},
+        { "FlyVideo 98/IR",
+          3, 0, 2, 0x8dfe00, {2, 3, 1, 1}, 
+          {0, 0x8dfe00, 0x800, 0x400, 0x8dfe00, 0 }},
 };
 #define TVCARDS (sizeof(tvcards)/sizeof(tvcard))
 
@@ -625,6 +636,7 @@
 
 extern inline void bt848_dma(struct bttv *btv, uint state)
 {
+printk("videodev: dma %d\n",state);
 	if (state)
 		btor(3, BT848_GPIO_DMA_CTL);
 	else
@@ -634,6 +646,7 @@
 
 static void bt848_cap(struct bttv *btv, uint state)
 {
+printk("videodev: cap %d\n",state);
 	if (state) 
 	{
 		btv->cap|=3;
@@ -1822,6 +1835,7 @@
 #endif
         int i;
 
+printk("BTTV: open\n");
         if (btv->user)
                 return -EBUSY;
         audio(btv, AUDIO_UNMUTE);
@@ -1921,11 +1935,14 @@
 	struct bttv *btv=(struct bttv *)dev;
  	int i;
   	
+        printk("bttv: ioctl cmd 0x%X\n", cmd);
+
 	switch (cmd)
 	{	
 		case VIDIOCGCAP:
 		{
 			struct video_capability b;
+printk("IOCtl: Line %d \n", __LINE__);
 			strcpy(b.name,btv->video_dev.name);
 			b.type = VID_TYPE_CAPTURE|
 			 	VID_TYPE_TUNER|
@@ -1947,6 +1964,7 @@
 		case VIDIOCGCHAN:
 		{
 			struct video_channel v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v, arg,sizeof(v)))
 				return -EFAULT;
 			v.flags=VIDEO_VC_AUDIO;
@@ -1977,6 +1995,7 @@
 		case VIDIOCSCHAN:
 		{
 			struct video_channel v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v, arg,sizeof(v)))
 				return -EFAULT;
                         
@@ -2004,6 +2023,7 @@
 		case VIDIOCGTUNER:
 		{
 			struct video_tuner v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v,arg,sizeof(v))!=0)
 				return -EFAULT;
 			if(v.tuner||btv->channel)	/* Only tuner 0 */
@@ -2028,6 +2048,7 @@
 		case VIDIOCSTUNER:
 		{
 			struct video_tuner v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v, arg, sizeof(v)))
 				return -EFAULT;
 			/* Only one channel has a tuner */
@@ -2053,6 +2074,7 @@
 		case VIDIOCGPICT:
 		{
 			struct video_picture p=btv->picture;
+printk("IOCtl: line %d \n", __LINE__);
 			if(btv->win.depth==8)
 				p.palette=VIDEO_PALETTE_HI240;
 			if(btv->win.depth==15)
@@ -2072,6 +2094,7 @@
 		{
 			struct video_picture p;
 			int format;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&p, arg,sizeof(p)))
 				return -EFAULT;
 			/* We want -128 to 127 we get 0-65535 */
@@ -2099,6 +2122,7 @@
 			struct video_clip *vcp = NULL;
 			int on;
 			
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&vw,arg,sizeof(vw)))
 				return -EFAULT;
 				
@@ -2172,6 +2196,7 @@
 		case VIDIOCGWIN:
 		{
 			struct video_window vw;
+printk("IOCtl: line %d \n", __LINE__);
 			/* Oh for a COBOL move corresponding .. */
 			vw.x=btv->win.x;
 			vw.y=btv->win.y;
@@ -2190,6 +2215,8 @@
 			int v;
 			if(copy_from_user(&v, arg,sizeof(v)))
 				return -EFAULT;
+
+printk("IOCtl: line %d v=%d\n", __LINE__, v);
 			if(v==0)
 			{
 				bt848_cap(btv,0);
@@ -2206,6 +2233,7 @@
 		case VIDIOCGFBUF:
 		{
 			struct video_buffer v;
+printk("IOCtl: line %d \n", __LINE__);
 			v.base=(void *)btv->win.vidadr;
 			v.height=btv->win.sheight;
 			v.width=btv->win.swidth;
@@ -2219,6 +2247,7 @@
 		case VIDIOCSFBUF:
 		{
 			struct video_buffer v;
+printk("IOCtl: line %d \n", __LINE__);
 #if LINUX_VERSION_CODE >= 0x020100
 			if(!capable(CAP_SYS_ADMIN))
 #else
@@ -2251,12 +2280,14 @@
 		}
 		case VIDIOCKEY:
 		{
+printk("IOCtl: line %d \n", __LINE__);
 			/* Will be handled higher up .. */
 			return 0;
 		}
 		case VIDIOCGFREQ:
 		{
 			unsigned long v=btv->win.freq;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_to_user(arg,&v,sizeof(v)))
 				return -EFAULT;
 			return 0;
@@ -2264,6 +2295,7 @@
 		case VIDIOCSFREQ:
 		{
 			unsigned long v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v, arg, sizeof(v)))
 				return -EFAULT;
 			btv->win.freq=v;
@@ -2274,6 +2306,7 @@
 		case VIDIOCGAUDIO:
 		{
 			struct video_audio v;
+printk("IOCtl: line %d \n", __LINE__);
 			v=btv->audio_dev;
 			v.flags&=~(VIDEO_AUDIO_MUTE|VIDEO_AUDIO_MUTABLE);
 			v.flags|=VIDEO_AUDIO_MUTABLE;
@@ -2327,6 +2360,7 @@
 		case VIDIOCSAUDIO:
 		{
 			struct video_audio v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v,arg, sizeof(v)))
 				return -EFAULT;
 			if(v.flags&VIDEO_AUDIO_MUTE)
@@ -2379,6 +2413,7 @@
 		}
 
 	        case VIDIOCSYNC:
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user((void *)&i,arg,sizeof(int)))
 				return -EFAULT;
 /*                        if(i>1 || i<0)
@@ -2425,6 +2460,7 @@
 			break;
 
                 case BTTV_FIELDNR: 
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_to_user((void *) arg, (void *) &btv->last_field, 
                                         sizeof(btv->last_field)))
 				return -EFAULT;
@@ -2432,6 +2468,7 @@
       
                 case BTTV_PLLSET: {
                         struct bttv_pll_info p;
+printk("IOCtl: line %d \n", __LINE__);
 #if LINUX_VERSION_CODE >= 0x020100
 			if(!capable(CAP_SYS_ADMIN))
 #else
@@ -2449,6 +2486,7 @@
 	        case VIDIOCMCAPTURE:
 		{
                         struct video_mmap vm;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user((void *) &vm, (void *) arg, sizeof(vm)))
 				return -EFAULT;
                         if (btv->frame_stat[vm.frame] == GBUFFER_GRABBING)
@@ -2459,6 +2497,7 @@
 		case VIDIOCGMBUF:
 		{
 			struct video_mbuf vm;
+printk("IOCtl: line %d \n", __LINE__);
 			memset(&vm, 0 , sizeof(vm));
 			vm.size=BTTV_MAX_FBUF*2;
 			vm.frames=2;
@@ -2472,6 +2511,7 @@
 		case VIDIOCGUNIT:
 		{
 			struct video_unit vu;
+printk("IOCtl: line %d \n", __LINE__);
 			vu.video=btv->video_dev.minor;
 			vu.vbi=btv->vbi_dev.minor;
 			if(btv->radio_dev.minor!=-1)
@@ -2492,6 +2532,7 @@
 		
 	        case BTTV_BURST_ON:
 		{
+printk("IOCtl: line %d \n", __LINE__);
 			tvnorms[0].scaledtwidth=1135-BURSTOFFSET-2;
 			tvnorms[0].hdelayx1=186-BURSTOFFSET;
 			tvnorms[2].scaledtwidth=1135-BURSTOFFSET-2;
@@ -2501,6 +2542,7 @@
 
 		case BTTV_BURST_OFF:
 		{
+printk("IOCtl: line %d \n", __LINE__);
 			tvnorms[0].scaledtwidth=1135;
 			tvnorms[0].hdelayx1=186;
 			tvnorms[2].scaledtwidth=1135;
@@ -2515,7 +2557,6 @@
                         
 		case BTTV_PICNR:
 		{
-			/* return picture;*/
 			return  0;
 		}
                         
@@ -3498,6 +3539,16 @@
         return 1;
 }
 
+#ifdef GPIOMON
+bttv_gpio_monitor_t bttv_set_gpio_monitor(bttv_gpio_monitor_t callback)
+{
+        bttv_gpio_monitor_t prev=gpio_monitor;
+  
+        gpio_monitor=callback;
+        return prev;
+}
+#endif
+
 static int init_bt848(int i)
 {
         struct bttv *btv = &bttvs[i];
@@ -3606,15 +3657,28 @@
 	/* clear interrupt status */
 	btwrite(0xfffffUL, BT848_INT_STAT);
         
+#ifdef GPIOMON
 	/* set interrupt mask */
 	btwrite(btv->triton1|
                 /*BT848_INT_PABORT|BT848_INT_RIPERR|BT848_INT_PPERR|
                   BT848_INT_FDSR|BT848_INT_FTRGT|BT848_INT_FBUS|*/
+                BT848_INT_GPINT|
                 BT848_INT_VSYNC|
 		BT848_INT_SCERR|
 		BT848_INT_RISCI|BT848_INT_OCERR|BT848_INT_VPRES|
 		BT848_INT_FMTCHG|BT848_INT_HLOCK,
 		BT848_INT_MASK);
+#else
+	/* set interrupt mask */
+	btwrite(btv->triton1|
+                /*BT848_INT_PABORT|BT848_INT_RIPERR|BT848_INT_PPERR|
+                  BT848_INT_FDSR|BT848_INT_FTRGT|BT848_INT_FBUS|*/
+                BT848_INT_VSYNC|
+		BT848_INT_SCERR|
+		BT848_INT_RISCI|BT848_INT_OCERR|BT848_INT_VPRES|
+		BT848_INT_FMTCHG|BT848_INT_HLOCK,
+		BT848_INT_MASK);
+#endif
 
 	make_vbitab(btv);
 	bt848_set_risc_jmps(btv);
@@ -3649,9 +3713,21 @@
 		IDEBUG(printk ("bttv%d:  stat %08x\n", btv->nr, stat));
 
 		/* get device status bits */
-		dstat=btread(BT848_DSTATUS);
-    
-		if (astat&BT848_INT_FMTCHG) 
+		dstat=	btread(BT848_DSTATUS);
+
+#ifdef GPIOMON
+                if ( (astat&BT848_INT_GPINT) )
+                  {
+                    unsigned long b;
+                    
+                    b=btread(BT848_GPIO_DATA);
+                    printk("bttv%d: GPIO: %04lx INT_STAT: %04lx \n", 
+                           btv->nr, b&0x1ff, (long)stat);
+                    (gpio_monitor) ? gpio_monitor(btv->nr, b) : 0;
+                  }
+#endif
+
+                if (astat&BT848_INT_FMTCHG) 
 		{
 			IDEBUG(printk ("bttv%d: IRQ_FMTCHG\n", btv->nr));
 			/*btv->win.norm&=
@@ -4171,8 +4247,48 @@
 	}
 }
 
-#ifdef MODULE
 
+#ifdef GPIOMON
+void setup_gpio_irq(int nr)
+{
+  /* Set up GPIOINT mask */
+  struct bttv *btv;                                                       
+  
+  btv = &bttvs[nr];
+  if(btv == NULL) {                                                       
+    printk("bttv%d: setup_gpio_irq: *btv == NULL\n",nr);
+    return;                                                         
+  };
+
+  btwrite(btread(BT848_GPIO_DMA_CTL)
+          |BT848_GPIO_DMA_CTL_GPINTC
+          ,BT848_GPIO_DMA_CTL);
+  btwrite(btread(BT848_GPIO_DMA_CTL)
+          |BT848_GPIO_DMA_CTL_GPINTI
+          ,BT848_GPIO_DMA_CTL);
+  btwrite(btread(BT848_INT_STAT)|BT848_INT_GPINT,
+          BT848_INT_STAT);
+  btwrite(btread(BT848_INT_MASK)|BT848_INT_GPINT
+          ,BT848_INT_MASK);
+
+};
+
+void reset_gpio_irq(int nr)
+{
+  /* Reset GPIOINT mask */
+  struct bttv *btv;                                                       
+  
+  btv = &bttvs[nr];
+  if(btv == NULL) {                                                       
+    printk("bttv%d: reset_gpio_irq: *btv == NULL\n",nr);
+    return;                                                         
+  };
+  btwrite(btread(BT848_INT_MASK)&(~BT848_INT_GPINT)
+          ,BT848_INT_MASK);
+};
+#endif /* GPIOMON */
+
+#ifdef MODULE
 int init_module(void)
 {
 #else
@@ -4193,8 +4309,13 @@
 			release_bttv();
 			return -EIO;
 		} 
+#ifdef GPIOMON
+                else {
+                  setup_gpio_irq(i);
+                }
+#endif
+                
 	}
-
 	return 0;
 }
 
@@ -4204,11 +4325,24 @@
 
 void cleanup_module(void)
 {
-        release_bttv();
+#ifdef GPIOMON
+    {
+      int i;
+      for (i=0; i<bttv_num; i++) 
+        reset_gpio_irq(i);
+    }
+#endif
+  release_bttv();
 }
 
 #endif
 
+#ifdef GPIOMON
+#if LINUX_VERSION_CODE >= 0x020100
+EXPORT_SYMBOL(bttv_set_gpio_monitor);
+#endif
+#endif
+
 /*
  * Local variables:
  * c-indent-level: 8
@@ -4222,3 +4356,12 @@
  * tab-width: 8
  * End:
  */
+
+
+
+
+
+
+
+
+
diff -u --recursive --new-file bttv-0.6.3/driver/bttv.h bttv-irctl/driver/bttv.h
--- bttv-0.6.3/driver/bttv.h	Thu Feb  4 00:50:42 1999
+++ bttv-irctl/driver/bttv.h	Fri Jul 23 22:04:04 1999
@@ -181,6 +181,11 @@
 };
 #endif
 
+#ifdef GPIOMON
+typedef void (*bttv_gpio_monitor_t)(int nr, unsigned long data);
+extern bttv_gpio_monitor_t bttv_set_gpio_monitor(bttv_gpio_monitor_t callback);
+#endif
+
 /*The following should be done in more portable way. It depends on define
   of _ALPHA_BTTV in the Makefile.*/
 
@@ -283,3 +288,20 @@
  
 
 #endif
diff -u --recursive --new-file bttv-0.6.3/driver/openbt.c bttv-irctl/driver/openbt.c
--- bttv-0.6.3/driver/openbt.c	Thu Jan  1 01:00:00 1970
+++ bttv-irctl/driver/openbt.c	Tue May  4 22:31:36 1999
@@ -0,0 +1,9 @@
+#include <stdio.h>
+
+int main(void) {
+    FILE *f=fopen("/dev/bttv","r");
+    
+    while (1) {
+	sleep(1);
+	};
+}
\ No newline at end of file
diff -u --recursive --new-file bttv-0.6.3/driver/readirctl.c bttv-irctl/driver/readirctl.c
--- bttv-0.6.3/driver/readirctl.c	Thu Jan  1 01:00:00 1970
+++ bttv-irctl/driver/readirctl.c	Tue Jul 27 01:16:03 1999
@@ -0,0 +1,52 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include "bttv.h"
+	     
+#define BUFLEN 256
+
+void binprint( unsigned b )
+{
+    int k, m=0x80;
+    
+    for( k=0; k<8; k++, m>>=1 ){
+	printf( "%1c", ( b & m )? '1' : '0' );
+    }; 
+}
+
+int main( void )
+{
+    FILE *fd;
+    unsigned char buf;
+    int r;
+    
+    fd=fopen("./IRCtl", "r");
+    if (fd==NULL) {
+	fprintf(stderr,"Can't open IRCtl\n");
+        exit(1);
+    };
+    
+    fprintf(stderr,"Opened IRCtl\n");
+    
+    while (1){
+	r=fread( &buf, sizeof(buf), 1, fd );
+	if (r>=0) {
+	  /* if (buf & 0xff) */ {
+		printf("0x%02X = %03d\n",
+			(unsigned)(buf & 0xff),
+			(unsigned)(buf & 0xff));
+	    };
+	    /*
+	    printf("GPIO: 0x%06X => 0x%06X %03d => %03d \n", 
+		prev & 0xFF, buf & 0xff,
+		prev & 0xFF, buf & 0xff );
+	    */
+	}
+	/*usleep(50000);*/
+    };
+};
+
diff -u --recursive --new-file bttv-0.6.3/driver/remote.c bttv-irctl/driver/remote.c
--- bttv-0.6.3/driver/remote.c	Thu Jan  1 01:00:00 1970
+++ bttv-irctl/driver/remote.c	Tue Jul 27 02:32:28 1999
@@ -0,0 +1,385 @@
+/*
+ * Remote control driver for the FlyVideo 98 TV-card
+ * 
+ * (L) by Pawel T. Jochym <jochym@ifj.edu.pl>
+ *        This code is licensed under GNU GPL
+ *        For newer versions look at:
+ *        http://wolf.ifj.edu.pl/~jochym/FlyVideo98/
+ *
+ * $Id: bttv063-gpiomon.diff,v 1.1 1999/07/27 09:15:28 jochym Exp $
+ *
+ */
+
+/*
+ * History:
+ * 0.0.1  First public release
+ * 
+ * 0.0.2  Lots of changes. Following suggecstions and 
+ *        code written by Unai Uribarri <unai@dobra.aic.uniovi.es>
+ *        Added blocking reads with wait queue, support for multiple
+ *        TV cards, changes in bttv part to further simplify it.
+ *        Also modified to support Lirc library/daemon (not fully tested)
+ *
+ * 0.0.3  Ported to kernel 2.2.10 bttv driver. Poll function added
+ *	  some clean-up.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/malloc.h>
+
+#if CONFIG_MODVERSIONS==1
+#define MODVERSIONS
+#include <linux/modversions.h>
+#endif        
+
+/* For character devices */
+#include <linux/fs.h>       /* The character device definitions are here */
+#include <asm/uaccess.h>
+#include <linux/wrapper.h>  /* A wrapper which does next to nothing at
+                             * at present, but may help for compatibility
+                             * with future versions of Linux */
+
+#include "bttv.h"
+#include "bt848.h"
+#include "remote.h"
+
+#define SUCCESS 0
+
+#define dprintk     if (debug) printk
+
+static int debug =  0; /* insmod parameter */
+
+/* Array of IRCtls structures */
+struct irctl irctls[MAX_IRCTL_DEVICES];
+
+#if LINUX_VERSION_CODE > 0x020100
+MODULE_PARM(debug,"i");
+#endif
+
+void remote_queue_key(int nr, unsigned long code)
+{
+	struct irctl *ir=&irctls[nr];
+	
+	code=(code & BT848_RMTCTL_MASK)>>BT848_RMTCTL_SHIFT;	
+#if 0	
+	dprintk("IRCtl%d: %x => %x\n", 
+		nr, (int)(0xff & prev), (int)(0xff & curr ));
+#endif
+
+	spin_lock(&ir->lock);
+	dprintk("IRCtl%d: %lx\n", nr, code);
+	
+	/* Check if buffer is full, if so drop chars */
+	if (((ir->tail+1)%BUFLEN) == ir->head) {
+		dprintk("IRCtl%d: Buffer overflow\n", nr);
+	} else {
+		/* We still have some space in the buffer */
+		ir->buffer[ir->tail++]=(unsigned char)code;
+		ir->tail%=BUFLEN;
+		wake_up_interruptible(&ir->wait);
+	}
+	spin_unlock(&ir->lock);
+}
+
+
+/* This function is called whenever a process attempts to open the device
+ * file */
+static int irctl_open(struct inode *inode, struct file *file)
+{
+	/* This is how you get the minor device number in case you have more
+	 * than one physical device using the driver. 
+	 */
+	int nr=MINOR(inode->i_rdev);
+	
+	dprintk("IRCtl: %d.%d open called\n", MAJOR(inode->i_rdev), nr);
+	if (nr>=MAX_IRCTL_DEVICES)
+		return -ENODEV;
+
+	/* We don't want to talk to two processes at the same time */
+	spin_lock(&irctls[nr].lock);
+	if (irctls[nr].open) {
+		spin_unlock(&irctls[nr].lock);
+		return -EBUSY;
+	}
+	++irctls[nr].open;
+	spin_unlock(&irctls[nr].lock);
+
+	/* Flush the buffer */
+	irctls[nr].head=irctls[nr].tail;
+
+	/* Make sure that the module isn't removed while the file is open by 
+	 * incrementing the usage count (the number of opened references to the
+	 * module, if it's not zero rmmod will fail)
+	 */
+	MOD_INC_USE_COUNT;
+	
+	return SUCCESS;
+}
+
+
+/* This function is called when a process closes the device file. It
+ * doesn't have a return value because it can't fail (you must ALWAYS
+ * be able to close a device). */
+static int irctl_release(struct inode *inode, struct file *file)
+{
+	int nr=MINOR(inode->i_rdev);
+	
+	spin_lock(&irctls[nr].lock);
+	dprintk ("IRCtl%d: release called\n", nr);
+ 
+	/* We're now ready for our next caller */
+	--irctls[nr].open;
+
+	/* Flush the buffer */
+	irctls[nr].head=irctls[nr].tail;
+	spin_unlock(&irctls[nr].lock);
+	
+	/* Decrement the usage count, 
+	 * otherwise once you opened the file you'll
+	 * never get rid of the module.
+	 */
+	MOD_DEC_USE_COUNT;
+	
+	return SUCCESS;
+}
+
+/*
+ *      Poll to see if we're readable
+ */
+static unsigned int irctl_poll(struct file *file, poll_table * wait)
+{
+	struct irctl *ir=&irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+	
+	dprintk("irctl%d: poll head=%d tail=%d\n",
+		MINOR(file->f_dentry->d_inode->i_rdev),
+		    ir->head, ir->tail);
+		    
+	poll_wait(file, &ir->wait, wait);
+	if (ir->head!=ir->tail)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static int irctl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int result;
+	unsigned long features = LIRC_CAN_REC_CODE, mode;
+
+	switch(cmd)
+	{
+		case LIRC_GET_FEATURES:
+			result = put_user(features,(unsigned long*)arg);
+			if(result)
+				return(result); 
+			break;
+		case LIRC_GET_REC_MODE:
+			result = put_user(LIRC_MODE_CODE,(unsigned long*)arg);
+			if(result)
+				return(result); 
+			break;
+		case LIRC_SET_REC_MODE:
+			result = get_user(mode,(unsigned long*)arg);
+			if(result)
+				return(result);
+			if(mode != LIRC_MODE_CODE)
+			{
+				return -ENOSYS;
+			}
+			break;
+		default:
+			return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+
+/* This function is called whenever a process which already opened the
+ * device file attempts to read from it. */
+static ssize_t irctl_read(struct file *file,
+			  char *buffer,   
+			  size_t length, 
+			  loff_t *ppos)     
+{
+	/* Minor device number */
+	struct irctl *ir=&irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+	int r;
+#if 1
+	dprintk("irctl_read(%p,%p,%d)\n",
+		file, buffer, length);
+#endif	
+	
+	spin_lock(&ir->lock);
+	
+	if (length != 1) {	/* LIRC_MODE_CODE */
+		spin_unlock(&ir->lock);
+		return -EIO;
+	}
+	if (ir->head==ir->tail) {
+		spin_unlock(&ir->lock);
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		if (signal_pending(current))
+		    return -ERESTARTSYS;
+		interruptible_sleep_on(&ir->wait);
+		current->state = TASK_RUNNING;
+		spin_lock(&ir->lock);
+	} 
+	r=put_user(ir->buffer[ir->head++],(unsigned char *)buffer);
+	ir->head%=BUFLEN;
+	spin_unlock(&ir->lock);
+	dprintk("irctl_read: ret %d data %d\n", r, *buffer);
+	return (r==0) ? 1 : -EIO;
+
+#if 0
+	    /*
+	      This version supports long reads
+	      switched off for now.
+	    */
+	/* Number of bytes actually written to the buffer */
+	int codes_read = 0;
+	while (codes_read < length)  {
+	    if (ir->head==ir->tail) {
+		spin_unlock(&ir->lock);
+		if (file->f_flags & O_NONBLOCK)
+		    return codes_read*sizeof(long);
+		if (signal_pending(current))
+		    return -ERESTARTSYS;
+		interruptible_sleep_on(&ir->wait);
+		current->state = TASK_RUNNING;
+		spin_lock(&ir->lock);
+	    } else if (ir->head<ir->tail) {
+		int count=MIN(ir->tail-ir->head, length);
+		copy_to_user(buffer+codes_read*sizeof(long),
+			ir->buffer+ir->head,
+			count*sizeof(long));
+		codes_read+=count;
+		ir->head+=count;
+	    } else {
+		int count=MIN(BUFLEN-ir->head, length);
+		copy_to_user(buffer+codes_read*sizeof(long),
+			ir->buffer+ir->head,
+			count*sizeof(long));
+		codes_read+=count;
+		ir->head=(ir->head+count)%BUFLEN;
+	    }
+	}
+	
+	dprintk ("Read %d bytes, %d left\n",
+		    codes_read*sizeof(long), (length-codes_read)*sizeof(long));
+		    
+	spin_unlock(&ir->lock);
+	/* Read functions are supposed to return the number of bytes
+	 * actually inserted into the buffer */
+	return codes_read*sizeof(long);
+#endif
+}
+
+
+/* Module Declarations ********************************************** */
+
+/* The major device number for the device. This is static because it 
+ * has to be accessible both for registration and for release. */
+static int Major;
+
+/* This structure will hold the functions to be called when 
+ * a process does something to the device we created. Since a pointer to
+ * this structure is kept in the devices table, it can't be local to
+ * init_module. NULL is for unimplemented functions. */
+
+struct file_operations Fops = {
+  NULL,   /* seek */
+  irctl_read, 
+  NULL,   /* write */
+  NULL,   /* readdir */
+  irctl_poll,   /* poll */
+  irctl_ioctl,   /* ioctl */
+  NULL,   /* mmap */
+  irctl_open,
+  NULL,   /* flush */
+  irctl_release  /* a.k.a. close */
+};
+
+
+/* ---------------------------------------------------------------------- */
+
+/* For now it must be a module, i'll figure out static version later
+   Dont try to use it as a static version !  */
+
+EXPORT_NO_SYMBOLS; 
+
+#ifdef MODULE
+int init_module(void)
+#else
+int i2c_remote_init(void)
+#endif
+{  	
+	int i;
+	
+	for (i=0; i<MAX_IRCTL_DEVICES; ++i) {
+		irctls[i].head=0;
+		irctls[i].tail=0;
+#if LINUX_VERSION_CODE >= 0x020100
+		irctls[i].wait=NULL;
+		irctls[i].lock=SPIN_LOCK_UNLOCKED;
+#endif
+	}
+    	/* Register the character device (atleast try) */
+	Major = module_register_chrdev(IRCTL_DEV_MAJOR, 
+				       IRCTL_DEV_NAME,
+				       &Fops);
+	
+	/* Negative values signify an error */
+	if (Major < 0) {
+		printk ("IRCtl device registration failed with %d\n",
+			Major);
+		return Major;
+	}
+	
+	bttv_set_gpio_monitor(remote_queue_key);
+
+	printk("IR Remote Control driver registered, at major %d \n", 
+		IRCTL_DEV_MAJOR);
+
+	return 0;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	int ret;
+	
+	bttv_set_gpio_monitor(NULL);
+	/* Unregister the device */
+	ret = module_unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME);
+ 
+	/* If there's an error, report it */ 
+	if (ret < 0){
+		printk("Error in module_unregister_chrdev: %d\n", ret);
+	} else {
+		dprintk("Module remote successfully unloaded\n");
+	}
+}
+#endif
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
+
+
+
+
+
+
+
+
diff -u --recursive --new-file bttv-0.6.3/driver/remote.h bttv-irctl/driver/remote.h
--- bttv-0.6.3/driver/remote.h	Thu Jan  1 01:00:00 1970
+++ bttv-irctl/driver/remote.h	Tue Jul 27 02:32:28 1999
@@ -0,0 +1,60 @@
+#ifndef REMOTE_H
+#define REMOTE_H
+/*
+   $Id: bttv063-gpiomon.diff,v 1.1 1999/07/27 09:15:28 jochym Exp $
+*/
+/*
+ * This driver is for a FlyVideo'98/FlyVideoII/ConferenceTV 
+ * card IR Remote Control
+ * (L) Pawel T. Jochym <jochym@ifj.edu.pl>
+ *     http://wolf.ifj.edu.pl/~jochym/
+ */
+
+#include <linux/ioctl.h>
+
+#define BT848_RMTCTL_MASK 0x1F8
+#define BT848_RMTCTL_RELEASED_MASK 0x100
+#define BT848_RMTCTL_SHIFT 3
+
+/* lirc.h constants */
+#define LIRC_MODE_RAW                  0x00000001
+#define LIRC_MODE_PULSE                0x00000002
+#define LIRC_MODE_MODE2                0x00000004
+#define LIRC_MODE_CODE                 0x00000008
+#define LIRC_MODE_LIRCCODE             0x00000010
+#define LIRC_MODE_STRING               0x00000020
+
+#define LIRC_MODE2REC(x) ((x) << 16)
+#define LIRC_CAN_REC_CODE              LIRC_MODE2REC(LIRC_MODE_CODE)
+
+#define LIRC_GET_FEATURES              _IOR('i', 0x00000000, __u32)
+#define LIRC_GET_REC_MODE              _IOR('i', 0x00000002, __u32)
+#define LIRC_SET_REC_MODE              _IOW('i', 0x00000012, __u32)
+
+
+/* We are using experimental range for now */
+#define IRCTL_DEV_MAJOR 61 
+#define MAX_IRCTL_DEVICES 4
+#define IRCTL_DEV_NAME "RemoteCtl"
+#define BUFLEN 512
+
+struct irctl 
+{
+  /* Buffer for key codes */
+  unsigned char buffer[BUFLEN];
+  /* Consumer/Producer pointers */ 
+  int head, tail, open;
+  spinlock_t lock;
+  struct wait_queue *wait;
+};
+
+extern void remote_queue_key(int nr, unsigned long code);
+
+#endif /* REMOTE_H */
+
+
+
+
+
+
+
diff -u --recursive --new-file bttv-0.6.3/driver/update bttv-irctl/driver/update
--- bttv-0.6.3/driver/update	Sat Jun 20 23:50:00 1998
+++ bttv-irctl/driver/update	Fri Jul 23 21:47:36 1999
@@ -24,6 +24,7 @@
 sync; sleep 1; sync
 
 # kill old modules ...
+xrmmod remote
 xrmmod bttv
 xrmmod msp3400
 xrmmod tuner
@@ -37,7 +38,7 @@
 xinsmod videodev
 xinsmod i2c		verbose=1 scan=1 i2c_debug=0
 test -f i2c_chardev.o && xinsmod i2c_chardev
-xinsmod tuner		debug=0 type=5 
+xinsmod tuner		debug=0 type=0
 xinsmod msp3400		
-xinsmod bttv		radio=1
-
+xinsmod bttv card=20 pll=1 radio=1
+xinsmod remote debug=1
diff -u --recursive --new-file bttv-0.6.3/driver/videodev.c bttv-irctl/driver/videodev.c
--- bttv-0.6.3/driver/videodev.c	Mon Sep 28 23:39:38 1998
+++ bttv-irctl/driver/videodev.c	Tue May  4 21:14:41 1999
@@ -250,10 +250,13 @@
 	unsigned int cmd, unsigned long arg)
 {
 	struct video_device *vfl=video_device[MINOR(inode->i_rdev)];
-	int err=vfl->ioctl(vfl, cmd, (void *)arg);
-
+	int err=-EINVAL;
+	
+	if (vfl)
+	  err=vfl->ioctl(vfl, cmd, (void *)arg);
+	
 	if(err!=-ENOIOCTLCMD)
-		return err;
+	  return err;
 	
 	switch(cmd)
 	{
