diff -u --recursive --new-file linux/drivers/char/Config.in linux-irctl/drivers/char/Config.in
--- linux/drivers/char/Config.in	Fri May  7 20:05:30 1999
+++ linux-irctl/drivers/char/Config.in	Mon Jul 26 22:14:40 1999
@@ -132,6 +132,9 @@
   if [ "$CONFIG_PCI" != "n" ]; then
     dep_tristate 'BT848 Video For Linux' CONFIG_VIDEO_BT848 $CONFIG_VIDEO_DEV
   fi
+  if [ "$CONFIG_VIDEO_BT848" != "n" ]; then
+    dep_tristate 'FlyVideo98 Remote Control' CONFIG_BTTV_REMOTE $CONFIG_VIDEO_BT848
+  fi
   if [ "$CONFIG_PARPORT" != "n" ]; then
     dep_tristate 'Quickcam BW Video For Linux' CONFIG_VIDEO_BWQCAM $CONFIG_VIDEO_DEV $CONFIG_PARPORT
     dep_tristate 'Colour QuickCam Video For Linux (EXPERIMENTAL)' CONFIG_VIDEO_CQCAM $CONFIG_VIDEO_DEV $CONFIG_PARPORT
diff -u --recursive --new-file linux/drivers/char/Makefile linux-irctl/drivers/char/Makefile
--- linux/drivers/char/Makefile	Fri May  7 20:05:30 1999
+++ linux-irctl/drivers/char/Makefile	Tue Jul 27 01:57:40 1999
@@ -317,6 +317,9 @@
   ifeq ($(CONFIG_VIDEO_BT848),m)
     M_OBJS += bttv.o msp3400.o tuner.o
     M_I2C=y
+    ifeq ($(CONFIG_BTTV_REMOTE),m)
+	M_OBJS += remote.o
+    endif
   endif
 endif
 
diff -u --recursive --new-file linux/drivers/char/bttv.c linux-irctl/drivers/char/bttv.c
--- linux/drivers/char/bttv.c	Tue Jun  8 01:18:17 1999
+++ linux-irctl/drivers/char/bttv.c	Tue Jul 27 02:04:46 1999
@@ -20,6 +20,11 @@
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
 
+#include <linux/config.h>
+#ifndef EXPORT_SYMTAB
+#define EXPORT_SYMTAB
+#endif
+
 #include <linux/module.h>
 #include <linux/version.h>
 #include <linux/delay.h>
@@ -119,6 +124,10 @@
 static int bttv_num;			/* number of Bt848s in use */
 static struct bttv bttvs[BTTV_MAX];
 
+#ifdef BTTV_GPIOMON
+static bttv_gpio_monitor_t gpio_monitor=NULL;
+#endif
+
 #define I2C_TIMING (0x7<<4)
 #define I2C_DELAY   10
 
@@ -548,6 +557,8 @@
         { 3, 1, 0, 2, 0x8300f8, { 2, 3, 1, 1,0}, {0x4fa007,0xcfa007,0xcfa007,0xcfa007,0xcfa007,0xcfa007}},
         /* AVEC Intercapture */
         { 3, 1, 9, 2, 0, { 2, 3, 1, 1}, { 0, 0, 0, 0, 0}},
+	/* Fly Video 98 */
+	{ 3, 1, 0, 2, 0x8dfe00, {2, 3, 1, 1}, {0, 0x8dfe00, 0x800, 0x400, 0x8dfe00, 0 }},
 };
 #define TVCARDS (sizeof(tvcards)/sizeof(tvcard))
 
@@ -3157,6 +3168,18 @@
 		bt848_dma(btv, 0);
 }
 
+
+
+#ifdef BTTV_GPIOMON
+bttv_gpio_monitor_t bttv_set_gpio_monitor(bttv_gpio_monitor_t callback)
+{
+        bttv_gpio_monitor_t prev=gpio_monitor;
+  
+        gpio_monitor=callback;
+        return prev;
+}
+#endif
+
 static int init_bt848(int i)
 {
         struct bttv *btv = &bttvs[i];
@@ -3270,15 +3293,26 @@
 	btwrite(0xfffffUL, BT848_INT_STAT);
         
 	/* set interrupt mask */
+#ifdef BTTV_GPIOMON
 	btwrite(btv->triton1|
                 /*BT848_INT_PABORT|BT848_INT_RIPERR|BT848_INT_PPERR|
                   BT848_INT_FDSR|BT848_INT_FTRGT|BT848_INT_FBUS|*/
+                BT848_INT_GPINT|
                 BT848_INT_VSYNC|
 		BT848_INT_SCERR|
 		BT848_INT_RISCI|BT848_INT_OCERR|BT848_INT_VPRES|
 		BT848_INT_FMTCHG|BT848_INT_HLOCK,
 		BT848_INT_MASK);
-
+#else
+	btwrite(btv->triton1|
+                /*BT848_INT_PABORT|BT848_INT_RIPERR|BT848_INT_PPERR|
+                  BT848_INT_FDSR|BT848_INT_FTRGT|BT848_INT_FBUS|*/
+                BT848_INT_VSYNC|
+		BT848_INT_SCERR|
+		BT848_INT_RISCI|BT848_INT_OCERR|BT848_INT_VPRES|
+		BT848_INT_FMTCHG|BT848_INT_HLOCK,
+		BT848_INT_MASK);
+#endif
 	make_vbitab(btv);
 	bt848_set_risc_jmps(btv);
   
@@ -3336,6 +3370,18 @@
 		/* get device status bits */
 		dstat=btread(BT848_DSTATUS);
     
+#ifdef BTTV_GPIOMON
+                if ( (astat&BT848_INT_GPINT) )
+        	{
+            		unsigned long b;
+                    
+                	b=btread(BT848_GPIO_DATA);
+                	IDEBUG(printk("bttv%d: GPIO: %04lx INT_STAT: %04lx \n", 
+                    		btv->nr, b&0x1ff, (long)stat));
+            		(gpio_monitor) ? gpio_monitor(btv->nr, b) : 0;
+			return;
+		}
+#endif
 		if (astat&BT848_INT_FMTCHG) 
 		{
 			IDEBUG(printk ("bttv%d: IRQ_FMTCHG\n", btv->nr));
@@ -3840,9 +3886,58 @@
 	}
 }
 
-#ifdef MODULE
+#ifdef BTTV_GPIOMON
+#if LINUX_VERSION_CODE >= 0x020100
+EXPORT_SYMBOL(bttv_set_gpio_monitor);
+#endif
+
+static void setup_gpio_irq(int nr)
+{
+	/* Set up GPIOINT mask */
+	struct bttv *btv;                                                       
+  
+	btv = &bttvs[nr];
+	printk("bttv%d: setup_gpio_irq\n",nr);
+	if(btv == NULL) {                                                       
+		printk("bttv%d: setup_gpio_irq: *btv == NULL\n",nr);
+		return;                                                         
+	};
+    
+    /**/
+	btwrite(btread(BT848_GPIO_DMA_CTL)
+    	    |BT848_GPIO_DMA_CTL_GPINTC
+    	    ,BT848_GPIO_DMA_CTL);
+	btwrite(btread(BT848_GPIO_DMA_CTL)
+	    |BT848_GPIO_DMA_CTL_GPINTI
+	    ,BT848_GPIO_DMA_CTL);
+	  
+	btwrite(btread(BT848_INT_STAT)|BT848_INT_GPINT,BT848_INT_STAT);
+	btwrite(btread(BT848_INT_MASK)|BT848_INT_GPINT,BT848_INT_MASK);
+    /**/
+
+};
+
+static void reset_gpio_irq(int nr)
+{
+  /* Reset GPIOINT mask */
+  struct bttv *btv;                                                       
+  
+  btv = &bttvs[nr];
+  if(btv == NULL) {                                                       
+    printk("bttv%d: reset_gpio_irq: *btv == NULL\n",nr);
+    return;                                                         
+  };
+  btwrite(btread(BT848_INT_MASK)&(~BT848_INT_GPINT)
+          ,BT848_INT_MASK);
+};
 
+#else
 EXPORT_NO_SYMBOLS;
+#endif
+
+
+
+#ifdef MODULE
 
 int init_module(void)
 {
@@ -3864,6 +3959,12 @@
 			release_bttv();
 			return -EIO;
 		} 
+#ifdef BTTV_GPIOMON
+                else 
+		{
+            		setup_gpio_irq(i);
+                }
+#endif
 	}
 
 	return 0;
@@ -3875,6 +3976,13 @@
 
 void cleanup_module(void)
 {
+#ifdef BTTV_GPIOMON
+	{
+              int i;
+              for (i=0; i<bttv_num; i++) 
+		    reset_gpio_irq(i);
+	}
+#endif
         release_bttv();
 }
 
diff -u --recursive --new-file linux/drivers/char/bttv.h linux-irctl/drivers/char/bttv.h
--- linux/drivers/char/bttv.h	Tue Jun  8 01:18:17 1999
+++ linux-irctl/drivers/char/bttv.h	Mon Jul 26 23:44:53 1999
@@ -22,6 +22,8 @@
 #define _BTTV_H_
 
 #define BTTV_VERSION_CODE 0x000523
+#define BTTV_GPIOMON 
+#define VIDEODAT
 
 #include <linux/types.h>
 #include <linux/wait.h>
@@ -164,6 +166,11 @@
 	int i2c_command;
 	int triton1;
 };
+#endif
+
+#ifdef BTTV_GPIOMON
+typedef void (*bttv_gpio_monitor_t)(int nr, unsigned long data);
+extern bttv_gpio_monitor_t bttv_set_gpio_monitor(bttv_gpio_monitor_t callback);
 #endif
 
 /*The following should be done in more portable way. It depends on define
diff -u --recursive --new-file linux/drivers/char/remote.c linux-irctl/drivers/char/remote.c
--- linux/drivers/char/remote.c	Thu Jan  1 01:00:00 1970
+++ linux-irctl/drivers/char/remote.c	Tue Jul 27 02:06:56 1999
@@ -0,0 +1,385 @@
+/*
+ * Remote control driver for the FlyVideo 98 TV-card
+ * 
+ * (L) by Pawel T. Jochym <jochym@ifj.edu.pl>
+ *        This code is licensed under GNU GPL
+ *        For newer versions look at:
+ *        http://wolf.ifj.edu.pl/~jochym/FlyVideo98/
+ *
+ * $Id: kbttv2210-gpiomon.diff,v 1.1 1999/07/27 09:15:28 jochym Exp $
+ *
+ */
+
+/*
+ * History:
+ * 0.0.1  First public release
+ * 
+ * 0.0.2  Lots of changes. Following suggecstions and 
+ *        code written by Unai Uribarri <unai@dobra.aic.uniovi.es>
+ *        Added blocking reads with wait queue, support for multiple
+ *        TV cards, changes in bttv part to further simplify it.
+ *        Also modified to support Lirc library/daemon (not fully tested)
+ *
+ * 0.0.3  Ported to kernel 2.2.10 bttv driver. Poll function added
+ *	  some clean-up.
+ */
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/delay.h>
+#include <linux/errno.h>
+#include <linux/mm.h>
+#include <linux/malloc.h>
+
+#if CONFIG_MODVERSIONS==1
+#define MODVERSIONS
+#include <linux/modversions.h>
+#endif        
+
+/* For character devices */
+#include <linux/fs.h>       /* The character device definitions are here */
+#include <asm/uaccess.h>
+#include <linux/wrapper.h>  /* A wrapper which does next to nothing at
+                             * at present, but may help for compatibility
+                             * with future versions of Linux */
+
+#include "bttv.h"
+#include "bt848.h"
+#include "remote.h"
+
+#define SUCCESS 0
+
+#define dprintk     if (debug) printk
+
+static int debug =  0; /* insmod parameter */
+
+/* Array of IRCtls structures */
+struct irctl irctls[MAX_IRCTL_DEVICES];
+
+#if LINUX_VERSION_CODE > 0x020100
+MODULE_PARM(debug,"i");
+#endif
+
+void remote_queue_key(int nr, unsigned long code)
+{
+	struct irctl *ir=&irctls[nr];
+	
+	code=(code & BT848_RMTCTL_MASK)>>BT848_RMTCTL_SHIFT;	
+#if 0	
+	dprintk("IRCtl%d: %x => %x\n", 
+		nr, (int)(0xff & prev), (int)(0xff & curr ));
+#endif
+
+	spin_lock(&ir->lock);
+	dprintk("IRCtl%d: %lx\n", nr, code);
+	
+	/* Check if buffer is full, if so drop chars */
+	if (((ir->tail+1)%BUFLEN) == ir->head) {
+		dprintk("IRCtl%d: Buffer overflow\n", nr);
+	} else {
+		/* We still have some space in the buffer */
+		ir->buffer[ir->tail++]=(unsigned char)code;
+		ir->tail%=BUFLEN;
+		wake_up_interruptible(&ir->wait);
+	}
+	spin_unlock(&ir->lock);
+}
+
+
+/* This function is called whenever a process attempts to open the device
+ * file */
+static int irctl_open(struct inode *inode, struct file *file)
+{
+	/* This is how you get the minor device number in case you have more
+	 * than one physical device using the driver. 
+	 */
+	int nr=MINOR(inode->i_rdev);
+	
+	dprintk("IRCtl: %d.%d open called\n", MAJOR(inode->i_rdev), nr);
+	if (nr>=MAX_IRCTL_DEVICES)
+		return -ENODEV;
+
+	/* We don't want to talk to two processes at the same time */
+	spin_lock(&irctls[nr].lock);
+	if (irctls[nr].open) {
+		spin_unlock(&irctls[nr].lock);
+		return -EBUSY;
+	}
+	++irctls[nr].open;
+	spin_unlock(&irctls[nr].lock);
+
+	/* Flush the buffer */
+	irctls[nr].head=irctls[nr].tail;
+
+	/* Make sure that the module isn't removed while the file is open by 
+	 * incrementing the usage count (the number of opened references to the
+	 * module, if it's not zero rmmod will fail)
+	 */
+	MOD_INC_USE_COUNT;
+	
+	return SUCCESS;
+}
+
+
+/* This function is called when a process closes the device file. It
+ * doesn't have a return value because it can't fail (you must ALWAYS
+ * be able to close a device). */
+static int irctl_release(struct inode *inode, struct file *file)
+{
+	int nr=MINOR(inode->i_rdev);
+	
+	spin_lock(&irctls[nr].lock);
+	dprintk ("IRCtl%d: release called\n", nr);
+ 
+	/* We're now ready for our next caller */
+	--irctls[nr].open;
+
+	/* Flush the buffer */
+	irctls[nr].head=irctls[nr].tail;
+	spin_unlock(&irctls[nr].lock);
+	
+	/* Decrement the usage count, 
+	 * otherwise once you opened the file you'll
+	 * never get rid of the module.
+	 */
+	MOD_DEC_USE_COUNT;
+	
+	return SUCCESS;
+}
+
+/*
+ *      Poll to see if we're readable
+ */
+static unsigned int irctl_poll(struct file *file, poll_table * wait)
+{
+	struct irctl *ir=&irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+	
+	dprintk("irctl%d: poll head=%d tail=%d\n",
+		MINOR(file->f_dentry->d_inode->i_rdev),
+		    ir->head, ir->tail);
+		    
+	poll_wait(file, &ir->wait, wait);
+	if (ir->head!=ir->tail)
+		return POLLIN | POLLRDNORM;
+	return 0;
+}
+
+static int irctl_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+{
+	int result;
+	unsigned long features = LIRC_CAN_REC_CODE, mode;
+
+	switch(cmd)
+	{
+		case LIRC_GET_FEATURES:
+			result = put_user(features,(unsigned long*)arg);
+			if(result)
+				return(result); 
+			break;
+		case LIRC_GET_REC_MODE:
+			result = put_user(LIRC_MODE_CODE,(unsigned long*)arg);
+			if(result)
+				return(result); 
+			break;
+		case LIRC_SET_REC_MODE:
+			result = get_user(mode,(unsigned long*)arg);
+			if(result)
+				return(result);
+			if(mode != LIRC_MODE_CODE)
+			{
+				return -ENOSYS;
+			}
+			break;
+		default:
+			return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+
+/* This function is called whenever a process which already opened the
+ * device file attempts to read from it. */
+static ssize_t irctl_read(struct file *file,
+			  char *buffer,   
+			  size_t length, 
+			  loff_t *ppos)     
+{
+	/* Minor device number */
+	struct irctl *ir=&irctls[MINOR(file->f_dentry->d_inode->i_rdev)];
+	int r;
+#if 1
+	dprintk("irctl_read(%p,%p,%d)\n",
+		file, buffer, length);
+#endif	
+	
+	spin_lock(&ir->lock);
+	
+	if (length != 1) {	/* LIRC_MODE_CODE */
+		spin_unlock(&ir->lock);
+		return -EIO;
+	}
+	if (ir->head==ir->tail) {
+		spin_unlock(&ir->lock);
+		if (file->f_flags & O_NONBLOCK)
+			return -EAGAIN;
+		if (signal_pending(current))
+		    return -ERESTARTSYS;
+		interruptible_sleep_on(&ir->wait);
+		current->state = TASK_RUNNING;
+		spin_lock(&ir->lock);
+	} 
+	r=put_user(ir->buffer[ir->head++],(unsigned char *)buffer);
+	ir->head%=BUFLEN;
+	spin_unlock(&ir->lock);
+	dprintk("irctl_read: ret %d data %d\n", r, *buffer);
+	return (r==0) ? 1 : -EIO;
+
+#if 0
+	    /*
+	      This version supports long reads
+	      switched off for now.
+	    */
+	/* Number of bytes actually written to the buffer */
+	int codes_read = 0;
+	while (codes_read < length)  {
+	    if (ir->head==ir->tail) {
+		spin_unlock(&ir->lock);
+		if (file->f_flags & O_NONBLOCK)
+		    return codes_read*sizeof(long);
+		if (signal_pending(current))
+		    return -ERESTARTSYS;
+		interruptible_sleep_on(&ir->wait);
+		current->state = TASK_RUNNING;
+		spin_lock(&ir->lock);
+	    } else if (ir->head<ir->tail) {
+		int count=MIN(ir->tail-ir->head, length);
+		copy_to_user(buffer+codes_read*sizeof(long),
+			ir->buffer+ir->head,
+			count*sizeof(long));
+		codes_read+=count;
+		ir->head+=count;
+	    } else {
+		int count=MIN(BUFLEN-ir->head, length);
+		copy_to_user(buffer+codes_read*sizeof(long),
+			ir->buffer+ir->head,
+			count*sizeof(long));
+		codes_read+=count;
+		ir->head=(ir->head+count)%BUFLEN;
+	    }
+	}
+	
+	dprintk ("Read %d bytes, %d left\n",
+		    codes_read*sizeof(long), (length-codes_read)*sizeof(long));
+		    
+	spin_unlock(&ir->lock);
+	/* Read functions are supposed to return the number of bytes
+	 * actually inserted into the buffer */
+	return codes_read*sizeof(long);
+#endif
+}
+
+
+/* Module Declarations ********************************************** */
+
+/* The major device number for the device. This is static because it 
+ * has to be accessible both for registration and for release. */
+static int Major;
+
+/* This structure will hold the functions to be called when 
+ * a process does something to the device we created. Since a pointer to
+ * this structure is kept in the devices table, it can't be local to
+ * init_module. NULL is for unimplemented functions. */
+
+struct file_operations Fops = {
+  NULL,   /* seek */
+  irctl_read, 
+  NULL,   /* write */
+  NULL,   /* readdir */
+  irctl_poll,   /* poll */
+  irctl_ioctl,   /* ioctl */
+  NULL,   /* mmap */
+  irctl_open,
+  NULL,   /* flush */
+  irctl_release  /* a.k.a. close */
+};
+
+
+/* ---------------------------------------------------------------------- */
+
+/* For now it must be a module, i'll figure out static version later
+   Dont try to use it as a static version !  */
+
+EXPORT_NO_SYMBOLS; 
+
+#ifdef MODULE
+int init_module(void)
+#else
+int i2c_remote_init(void)
+#endif
+{  	
+	int i;
+	
+	for (i=0; i<MAX_IRCTL_DEVICES; ++i) {
+		irctls[i].head=0;
+		irctls[i].tail=0;
+#if LINUX_VERSION_CODE >= 0x020100
+		irctls[i].wait=NULL;
+		irctls[i].lock=SPIN_LOCK_UNLOCKED;
+#endif
+	}
+    	/* Register the character device (atleast try) */
+	Major = module_register_chrdev(IRCTL_DEV_MAJOR, 
+				       IRCTL_DEV_NAME,
+				       &Fops);
+	
+	/* Negative values signify an error */
+	if (Major < 0) {
+		printk ("IRCtl device registration failed with %d\n",
+			Major);
+		return Major;
+	}
+	
+	bttv_set_gpio_monitor(remote_queue_key);
+
+	printk("IR Remote Control driver registered, at major %d \n", 
+		IRCTL_DEV_MAJOR);
+
+	return 0;
+}
+
+#ifdef MODULE
+void cleanup_module(void)
+{
+	int ret;
+	
+	bttv_set_gpio_monitor(NULL);
+	/* Unregister the device */
+	ret = module_unregister_chrdev(IRCTL_DEV_MAJOR, IRCTL_DEV_NAME);
+ 
+	/* If there's an error, report it */ 
+	if (ret < 0){
+		printk("Error in module_unregister_chrdev: %d\n", ret);
+	} else {
+		dprintk("Module remote successfully unloaded\n");
+	}
+}
+#endif
+
+/*
+ * Overrides for Emacs so that we follow Linus's tabbing style.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * End:
+ */
+
+
+
+
+
+
+
+
diff -u --recursive --new-file linux/drivers/char/remote.h linux-irctl/drivers/char/remote.h
--- linux/drivers/char/remote.h	Thu Jan  1 01:00:00 1970
+++ linux-irctl/drivers/char/remote.h	Mon Jul 26 22:25:29 1999
@@ -0,0 +1,60 @@
+#ifndef REMOTE_H
+#define REMOTE_H
+/*
+   $Id: kbttv2210-gpiomon.diff,v 1.1 1999/07/27 09:15:28 jochym Exp $
+*/
+/*
+ * This driver is for a FlyVideo'98/FlyVideoII/ConferenceTV 
+ * card IR Remote Control
+ * (L) Pawel T. Jochym <jochym@ifj.edu.pl>
+ *     http://wolf.ifj.edu.pl/~jochym/
+ */
+
+#include <linux/ioctl.h>
+
+#define BT848_RMTCTL_MASK 0x1F8
+#define BT848_RMTCTL_RELEASED_MASK 0x100
+#define BT848_RMTCTL_SHIFT 3
+
+/* lirc.h constants */
+#define LIRC_MODE_RAW                  0x00000001
+#define LIRC_MODE_PULSE                0x00000002
+#define LIRC_MODE_MODE2                0x00000004
+#define LIRC_MODE_CODE                 0x00000008
+#define LIRC_MODE_LIRCCODE             0x00000010
+#define LIRC_MODE_STRING               0x00000020
+
+#define LIRC_MODE2REC(x) ((x) << 16)
+#define LIRC_CAN_REC_CODE              LIRC_MODE2REC(LIRC_MODE_CODE)
+
+#define LIRC_GET_FEATURES              _IOR('i', 0x00000000, __u32)
+#define LIRC_GET_REC_MODE              _IOR('i', 0x00000002, __u32)
+#define LIRC_SET_REC_MODE              _IOW('i', 0x00000012, __u32)
+
+
+/* We are using experimental range for now */
+#define IRCTL_DEV_MAJOR 61 
+#define MAX_IRCTL_DEVICES 4
+#define IRCTL_DEV_NAME "RemoteCtl"
+#define BUFLEN 512
+
+struct irctl 
+{
+  /* Buffer for key codes */
+  unsigned char buffer[BUFLEN];
+  /* Consumer/Producer pointers */ 
+  int head, tail, open;
+  spinlock_t lock;
+  struct wait_queue *wait;
+};
+
+extern void remote_queue_key(int nr, unsigned long code);
+
+#endif /* REMOTE_H */
