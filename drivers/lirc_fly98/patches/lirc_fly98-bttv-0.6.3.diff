diff -u --recursive --new-file bttv-0.6.3/driver/MAKEDEV bttv-irctl/driver/MAKEDEV
--- bttv-0.6.3/driver/MAKEDEV	Tue Sep 29 02:31:30 1998
+++ bttv-irctl/driver/MAKEDEV	Thu Apr 29 01:11:38 1999
@@ -26,3 +26,6 @@
 makedev bttv 0
 makedev bttv-fm 64
 makedev bttv-vbi 224
+
+echo "*** Testing IRCtl in FV98 ***"
+mknod IRCtl c 61 0
diff -u --recursive --new-file bttv-0.6.3/driver/Makefile bttv-irctl/driver/Makefile
--- bttv-0.6.3/driver/Makefile	Thu Feb  4 00:51:18 1999
+++ bttv-irctl/driver/Makefile	Sat Jul 24 01:16:14 1999
@@ -9,7 +9,7 @@
 # 5: Philips PAL tuner
 # 6: Temic NTSC tuner
 # 7: Temic PAL tuner
-# TUNER=0
+TUNER=0
 # Do not select the tuner type here!
 # Edit the type argument for the tuner module in "update"!
 
@@ -35,7 +35,7 @@
 # 17: PXC200
 # 18: AVermedia98
 # 19: FlyVideo98 (newer FlyVideo cards)
-CARD=15
+CARD=19
 # This can be set using module parameters too.
 
 
@@ -51,7 +51,7 @@
 # use 1 or 2 if you have a Bt848A, Bt849, Bt878, Bt879
 # 1 == 28 MHz crystal installed
 # 2 == 34 MHz crystal installed
-PLL=-DUSE_PLL=2
+PLL=-DUSE_PLL=1
 # This can be set using module parameters too.
 
 
@@ -67,17 +67,18 @@
 #KERNEL_LOCATION=/usr/src/kernel/2.0.35
 #KERNEL_LOCATION=/usr/src/kernel/$(CURRENT)
 #KERNEL_LOCATION=/usr/src/kernel/vger
-KERNEL_LOCATION=/usr/src/linux
+KERNEL_LOCATION=/usr/src/local/linux
 
 
 #################################################
 # some magic for using linux kernel settings
 # when compiling module(s)
 
 M_OBJS       = bttv.o msp3400.o tuner.o #i2c_chardev.o
 MX_OBJS      = videodev.o i2c.o
 EXTRA_CFLAGS = -DTUNER_DEFAULT=$(TUNER) -DCARD_DEFAULT=$(CARD) \
-	-DBTTV_MAJOR=$(BTTV_MAJOR) $(INTERFACE) $(MSP) $(PLL) #-DVIDEODAT
+	-DBTTV_MAJOR=$(BTTV_MAJOR) $(INTERFACE) $(MSP) $(PLL) \
+	-DVIDEODAT -DGPIOMON
 
 here:
 	DIR=`pwd`; (cd $(KERNEL_LOCATION); make SUBDIRS=$$DIR modules)
@@ -85,8 +86,11 @@
 install:
 	su -c "cp -v $(M_OBJS) $(MX_OBJS) /lib/modules/$(CURRENT)/misc"
 
+readir: readirctl.c
+	cc readirctl.c -o readir
+
 clean:
-	-rm -f $(M_OBJS) $(MX_OBJS) .*.o.flags *~
+	-rm -f $(M_OBJS) $(MX_OBJS) .*.o.flags *~ readir
 
 include $(KERNEL_LOCATION)/Rules.make
 
diff -u --recursive --new-file bttv-0.6.3/driver/bttv.c bttv-irctl/driver/bttv.c
--- bttv-0.6.3/driver/bttv.c	Sun Feb  7 22:49:48 1999
+++ bttv-irctl/driver/bttv.c	Fri Jul 23 22:07:21 1999
@@ -18,6 +18,10 @@
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 */
+#include <linux/config.h>
+#ifndef EXPORT_SYMTAB
+#define EXPORT_SYMTAB
+#endif
 
 #include <linux/module.h>
 #include <linux/delay.h>
@@ -130,6 +134,10 @@
 static int bttv_num;			/* number of Bt848s in use */
 static struct bttv bttvs[BTTV_MAX];
 
+#ifdef GPIOMON
+static bttv_gpio_monitor_t gpio_monitor=NULL;
+#endif
+
 #define I2C_TIMING (0x7<<4)
 #define I2C_DELAY   10
 
@@ -580,6 +588,9 @@
         { "FlyVideo 98",
           3, 0, 2, 0x8dff00, {2, 3, 1, 1}, 
           {0, 0x8dff00, 0x800, 0x400, 0x8dff00, 0 }},
+        { "FlyVideo 98/IR",
+          3, 0, 2, 0x8dfe00, {2, 3, 1, 1}, 
+          {0, 0x8dfe00, 0x800, 0x400, 0x8dfe00, 0 }},
 };
 #define TVCARDS (sizeof(tvcards)/sizeof(tvcard))
 
@@ -625,6 +636,7 @@
 
 extern inline void bt848_dma(struct bttv *btv, uint state)
 {
+printk("videodev: dma %d\n",state);
 	if (state)
 		btor(3, BT848_GPIO_DMA_CTL);
 	else
@@ -634,6 +646,7 @@
 
 static void bt848_cap(struct bttv *btv, uint state)
 {
+printk("videodev: cap %d\n",state);
 	if (state) 
 	{
 		btv->cap|=3;
@@ -1822,6 +1835,7 @@
 #endif
         int i;
 
+printk("BTTV: open\n");
         if (btv->user)
                 return -EBUSY;
         audio(btv, AUDIO_UNMUTE);
@@ -1921,11 +1935,14 @@
 	struct bttv *btv=(struct bttv *)dev;
  	int i;
   	
+        printk("bttv: ioctl cmd 0x%X\n", cmd);
+
 	switch (cmd)
 	{	
 		case VIDIOCGCAP:
 		{
 			struct video_capability b;
+printk("IOCtl: Line %d \n", __LINE__);
 			strcpy(b.name,btv->video_dev.name);
 			b.type = VID_TYPE_CAPTURE|
 			 	VID_TYPE_TUNER|
@@ -1947,6 +1964,7 @@
 		case VIDIOCGCHAN:
 		{
 			struct video_channel v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v, arg,sizeof(v)))
 				return -EFAULT;
 			v.flags=VIDEO_VC_AUDIO;
@@ -1977,6 +1995,7 @@
 		case VIDIOCSCHAN:
 		{
 			struct video_channel v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v, arg,sizeof(v)))
 				return -EFAULT;
                         
@@ -2004,6 +2023,7 @@
 		case VIDIOCGTUNER:
 		{
 			struct video_tuner v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v,arg,sizeof(v))!=0)
 				return -EFAULT;
 			if(v.tuner||btv->channel)	/* Only tuner 0 */
@@ -2028,6 +2048,7 @@
 		case VIDIOCSTUNER:
 		{
 			struct video_tuner v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v, arg, sizeof(v)))
 				return -EFAULT;
 			/* Only one channel has a tuner */
@@ -2053,6 +2074,7 @@
 		case VIDIOCGPICT:
 		{
 			struct video_picture p=btv->picture;
+printk("IOCtl: line %d \n", __LINE__);
 			if(btv->win.depth==8)
 				p.palette=VIDEO_PALETTE_HI240;
 			if(btv->win.depth==15)
@@ -2072,6 +2094,7 @@
 		{
 			struct video_picture p;
 			int format;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&p, arg,sizeof(p)))
 				return -EFAULT;
 			/* We want -128 to 127 we get 0-65535 */
@@ -2099,6 +2122,7 @@
 			struct video_clip *vcp = NULL;
 			int on;
 			
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&vw,arg,sizeof(vw)))
 				return -EFAULT;
 				
@@ -2172,6 +2196,7 @@
 		case VIDIOCGWIN:
 		{
 			struct video_window vw;
+printk("IOCtl: line %d \n", __LINE__);
 			/* Oh for a COBOL move corresponding .. */
 			vw.x=btv->win.x;
 			vw.y=btv->win.y;
@@ -2190,6 +2215,8 @@
 			int v;
 			if(copy_from_user(&v, arg,sizeof(v)))
 				return -EFAULT;
+
+printk("IOCtl: line %d v=%d\n", __LINE__, v);
 			if(v==0)
 			{
 				bt848_cap(btv,0);
@@ -2206,6 +2233,7 @@
 		case VIDIOCGFBUF:
 		{
 			struct video_buffer v;
+printk("IOCtl: line %d \n", __LINE__);
 			v.base=(void *)btv->win.vidadr;
 			v.height=btv->win.sheight;
 			v.width=btv->win.swidth;
@@ -2219,6 +2247,7 @@
 		case VIDIOCSFBUF:
 		{
 			struct video_buffer v;
+printk("IOCtl: line %d \n", __LINE__);
 #if LINUX_VERSION_CODE >= 0x020100
 			if(!capable(CAP_SYS_ADMIN))
 #else
@@ -2251,12 +2280,14 @@
 		}
 		case VIDIOCKEY:
 		{
+printk("IOCtl: line %d \n", __LINE__);
 			/* Will be handled higher up .. */
 			return 0;
 		}
 		case VIDIOCGFREQ:
 		{
 			unsigned long v=btv->win.freq;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_to_user(arg,&v,sizeof(v)))
 				return -EFAULT;
 			return 0;
@@ -2264,6 +2295,7 @@
 		case VIDIOCSFREQ:
 		{
 			unsigned long v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v, arg, sizeof(v)))
 				return -EFAULT;
 			btv->win.freq=v;
@@ -2274,6 +2306,7 @@
 		case VIDIOCGAUDIO:
 		{
 			struct video_audio v;
+printk("IOCtl: line %d \n", __LINE__);
 			v=btv->audio_dev;
 			v.flags&=~(VIDEO_AUDIO_MUTE|VIDEO_AUDIO_MUTABLE);
 			v.flags|=VIDEO_AUDIO_MUTABLE;
@@ -2327,6 +2360,7 @@
 		case VIDIOCSAUDIO:
 		{
 			struct video_audio v;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user(&v,arg, sizeof(v)))
 				return -EFAULT;
 			if(v.flags&VIDEO_AUDIO_MUTE)
@@ -2379,6 +2413,7 @@
 		}
 
 	        case VIDIOCSYNC:
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user((void *)&i,arg,sizeof(int)))
 				return -EFAULT;
 /*                        if(i>1 || i<0)
@@ -2425,6 +2460,7 @@
 			break;
 
                 case BTTV_FIELDNR: 
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_to_user((void *) arg, (void *) &btv->last_field, 
                                         sizeof(btv->last_field)))
 				return -EFAULT;
@@ -2432,6 +2468,7 @@
       
                 case BTTV_PLLSET: {
                         struct bttv_pll_info p;
+printk("IOCtl: line %d \n", __LINE__);
 #if LINUX_VERSION_CODE >= 0x020100
 			if(!capable(CAP_SYS_ADMIN))
 #else
@@ -2449,6 +2486,7 @@
 	        case VIDIOCMCAPTURE:
 		{
                         struct video_mmap vm;
+printk("IOCtl: line %d \n", __LINE__);
 			if(copy_from_user((void *) &vm, (void *) arg, sizeof(vm)))
 				return -EFAULT;
                         if (btv->frame_stat[vm.frame] == GBUFFER_GRABBING)
@@ -2459,6 +2497,7 @@
 		case VIDIOCGMBUF:
 		{
 			struct video_mbuf vm;
+printk("IOCtl: line %d \n", __LINE__);
 			memset(&vm, 0 , sizeof(vm));
 			vm.size=BTTV_MAX_FBUF*2;
 			vm.frames=2;
@@ -2472,6 +2511,7 @@
 		case VIDIOCGUNIT:
 		{
 			struct video_unit vu;
+printk("IOCtl: line %d \n", __LINE__);
 			vu.video=btv->video_dev.minor;
 			vu.vbi=btv->vbi_dev.minor;
 			if(btv->radio_dev.minor!=-1)
@@ -2492,6 +2532,7 @@
 		
 	        case BTTV_BURST_ON:
 		{
+printk("IOCtl: line %d \n", __LINE__);
 			tvnorms[0].scaledtwidth=1135-BURSTOFFSET-2;
 			tvnorms[0].hdelayx1=186-BURSTOFFSET;
 			tvnorms[2].scaledtwidth=1135-BURSTOFFSET-2;
@@ -2501,6 +2542,7 @@
 
 		case BTTV_BURST_OFF:
 		{
+printk("IOCtl: line %d \n", __LINE__);
 			tvnorms[0].scaledtwidth=1135;
 			tvnorms[0].hdelayx1=186;
 			tvnorms[2].scaledtwidth=1135;
@@ -2515,7 +2557,6 @@
                         
 		case BTTV_PICNR:
 		{
-			/* return picture;*/
 			return  0;
 		}
                         
@@ -3498,6 +3539,16 @@
         return 1;
 }
 
+#ifdef GPIOMON
+bttv_gpio_monitor_t bttv_set_gpio_monitor(bttv_gpio_monitor_t callback)
+{
+        bttv_gpio_monitor_t prev=gpio_monitor;
+  
+        gpio_monitor=callback;
+        return prev;
+}
+#endif
+
 static int init_bt848(int i)
 {
         struct bttv *btv = &bttvs[i];
@@ -3606,15 +3657,28 @@
 	/* clear interrupt status */
 	btwrite(0xfffffUL, BT848_INT_STAT);
         
+#ifdef GPIOMON
 	/* set interrupt mask */
 	btwrite(btv->triton1|
                 /*BT848_INT_PABORT|BT848_INT_RIPERR|BT848_INT_PPERR|
                   BT848_INT_FDSR|BT848_INT_FTRGT|BT848_INT_FBUS|*/
+                BT848_INT_GPINT|
                 BT848_INT_VSYNC|
 		BT848_INT_SCERR|
 		BT848_INT_RISCI|BT848_INT_OCERR|BT848_INT_VPRES|
 		BT848_INT_FMTCHG|BT848_INT_HLOCK,
 		BT848_INT_MASK);
+#else
+	/* set interrupt mask */
+	btwrite(btv->triton1|
+                /*BT848_INT_PABORT|BT848_INT_RIPERR|BT848_INT_PPERR|
+                  BT848_INT_FDSR|BT848_INT_FTRGT|BT848_INT_FBUS|*/
+                BT848_INT_VSYNC|
+		BT848_INT_SCERR|
+		BT848_INT_RISCI|BT848_INT_OCERR|BT848_INT_VPRES|
+		BT848_INT_FMTCHG|BT848_INT_HLOCK,
+		BT848_INT_MASK);
+#endif
 
 	make_vbitab(btv);
 	bt848_set_risc_jmps(btv);
@@ -3649,9 +3713,21 @@
 		IDEBUG(printk ("bttv%d:  stat %08x\n", btv->nr, stat));
 
 		/* get device status bits */
-		dstat=btread(BT848_DSTATUS);
-    
-		if (astat&BT848_INT_FMTCHG) 
+		dstat=	btread(BT848_DSTATUS);
+
+#ifdef GPIOMON
+                if ( (astat&BT848_INT_GPINT) )
+                  {
+                    unsigned long b;
+                    
+                    b=btread(BT848_GPIO_DATA);
+                    printk("bttv%d: GPIO: %04lx INT_STAT: %04lx \n", 
+                           btv->nr, b&0x1ff, (long)stat);
+                    (gpio_monitor) ? gpio_monitor(btv->nr, b) : 0;
+                  }
+#endif
+
+                if (astat&BT848_INT_FMTCHG) 
 		{
 			IDEBUG(printk ("bttv%d: IRQ_FMTCHG\n", btv->nr));
 			/*btv->win.norm&=
@@ -4171,8 +4247,48 @@
 	}
 }
 
-#ifdef MODULE
 
+#ifdef GPIOMON
+void setup_gpio_irq(int nr)
+{
+  /* Set up GPIOINT mask */
+  struct bttv *btv;                                                       
+  
+  btv = &bttvs[nr];
+  if(btv == NULL) {                                                       
+    printk("bttv%d: setup_gpio_irq: *btv == NULL\n",nr);
+    return;                                                         
+  };
+
+  btwrite(btread(BT848_GPIO_DMA_CTL)
+          |BT848_GPIO_DMA_CTL_GPINTC
+          ,BT848_GPIO_DMA_CTL);
+  btwrite(btread(BT848_GPIO_DMA_CTL)
+          |BT848_GPIO_DMA_CTL_GPINTI
+          ,BT848_GPIO_DMA_CTL);
+  btwrite(btread(BT848_INT_STAT)|BT848_INT_GPINT,
+          BT848_INT_STAT);
+  btwrite(btread(BT848_INT_MASK)|BT848_INT_GPINT
+          ,BT848_INT_MASK);
+
+};
+
+void reset_gpio_irq(int nr)
+{
+  /* Reset GPIOINT mask */
+  struct bttv *btv;                                                       
+  
+  btv = &bttvs[nr];
+  if(btv == NULL) {                                                       
+    printk("bttv%d: reset_gpio_irq: *btv == NULL\n",nr);
+    return;                                                         
+  };
+  btwrite(btread(BT848_INT_MASK)&(~BT848_INT_GPINT)
+          ,BT848_INT_MASK);
+};
+#endif /* GPIOMON */
+
+#ifdef MODULE
 int init_module(void)
 {
 #else
@@ -4193,8 +4309,13 @@
 			release_bttv();
 			return -EIO;
 		} 
+#ifdef GPIOMON
+                else {
+                  setup_gpio_irq(i);
+                }
+#endif
+                
 	}
-
 	return 0;
 }
 
@@ -4204,11 +4325,24 @@
 
 void cleanup_module(void)
 {
-        release_bttv();
+#ifdef GPIOMON
+    {
+      int i;
+      for (i=0; i<bttv_num; i++) 
+        reset_gpio_irq(i);
+    }
+#endif
+  release_bttv();
 }
 
 #endif
 
+#ifdef GPIOMON
+#if LINUX_VERSION_CODE >= 0x020100
+EXPORT_SYMBOL(bttv_set_gpio_monitor);
+#endif
+#endif
+
 /*
  * Local variables:
  * c-indent-level: 8
@@ -4222,3 +4356,12 @@
  * tab-width: 8
  * End:
  */
+
+
+
+
+
+
+
+
+
diff -u --recursive --new-file bttv-0.6.3/driver/bttv.h bttv-irctl/driver/bttv.h
--- bttv-0.6.3/driver/bttv.h	Thu Feb  4 00:50:42 1999
+++ bttv-irctl/driver/bttv.h	Fri Jul 23 22:04:04 1999
@@ -181,6 +181,11 @@
 };
 #endif
 
+#ifdef GPIOMON
+typedef void (*bttv_gpio_monitor_t)(int nr, unsigned long data);
+extern bttv_gpio_monitor_t bttv_set_gpio_monitor(bttv_gpio_monitor_t callback);
+#endif
+
 /*The following should be done in more portable way. It depends on define
   of _ALPHA_BTTV in the Makefile.*/
 
@@ -283,3 +288,20 @@
  
 
 #endif
diff -u --recursive --new-file bttv-0.6.3/driver/openbt.c bttv-irctl/driver/openbt.c
--- bttv-0.6.3/driver/openbt.c	Thu Jan  1 01:00:00 1970
+++ bttv-irctl/driver/openbt.c	Tue May  4 22:31:36 1999
@@ -0,0 +1,9 @@
+#include <stdio.h>
+
+int main(void) {
+    FILE *f=fopen("/dev/bttv","r");
+    
+    while (1) {
+	sleep(1);
+	};
+}
\ No newline at end of file
diff -u --recursive --new-file bttv-0.6.3/driver/readirctl.c bttv-irctl/driver/readirctl.c
--- bttv-0.6.3/driver/readirctl.c	Thu Jan  1 01:00:00 1970
+++ bttv-irctl/driver/readirctl.c	Tue Jul 27 01:16:03 1999
@@ -0,0 +1,52 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/ioctl.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include "bttv.h"
+	     
+#define BUFLEN 256
+
+void binprint( unsigned b )
+{
+    int k, m=0x80;
+    
+    for( k=0; k<8; k++, m>>=1 ){
+	printf( "%1c", ( b & m )? '1' : '0' );
+    }; 
+}
+
+int main( void )
+{
+    FILE *fd;
+    unsigned char buf;
+    int r;
+    
+    fd=fopen("./IRCtl", "r");
+    if (fd==NULL) {
+	fprintf(stderr,"Can't open IRCtl\n");
+        exit(1);
+    };
+    
+    fprintf(stderr,"Opened IRCtl\n");
+    
+    while (1){
+	r=fread( &buf, sizeof(buf), 1, fd );
+	if (r>=0) {
+	  /* if (buf & 0xff) */ {
+		printf("0x%02X = %03d\n",
+			(unsigned)(buf & 0xff),
+			(unsigned)(buf & 0xff));
+	    };
+	    /*
+	    printf("GPIO: 0x%06X => 0x%06X %03d => %03d \n", 
+		prev & 0xFF, buf & 0xff,
+		prev & 0xFF, buf & 0xff );
+	    */
+	}
+	/*usleep(50000);*/
+    };
+};
+
diff -u --recursive --new-file bttv-0.6.3/driver/videodev.c bttv-irctl/driver/videodev.c
--- bttv-0.6.3/driver/videodev.c	Mon Sep 28 23:39:38 1998
+++ bttv-irctl/driver/videodev.c	Tue May  4 21:14:41 1999
@@ -250,10 +250,13 @@
 	unsigned int cmd, unsigned long arg)
 {
 	struct video_device *vfl=video_device[MINOR(inode->i_rdev)];
-	int err=vfl->ioctl(vfl, cmd, (void *)arg);
-
+	int err=-EINVAL;
+	
+	if (vfl)
+	  err=vfl->ioctl(vfl, cmd, (void *)arg);
+	
 	if(err!=-ENOIOCTLCMD)
-		return err;
+	  return err;
 	
 	switch(cmd)
 	{
